<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Quansight Labs (Posts about Python)</title><link>https://labs.quansight.org/</link><description></description><atom:link href="https://labs.quansight.org/categories/python.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2021 &lt;a href="mailto:info@quansight.com"&gt;Quansight Labs Team&lt;/a&gt; </copyright><lastBuildDate>Mon, 09 Aug 2021 10:47:02 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Rethinking Jupyter Interactive Documentation</title><link>https://labs.quansight.org/blog/2021/05/rethinking-jupyter-documentation/</link><dc:creator>Matthias Bussonnier</dc:creator><description>&lt;div&gt;&lt;p&gt;Jupyter Notebook first release was 8 years ago – under the IPython Notebook
name at the time. Even if notebooks were not invented by Jupyter; they were
definitely democratized by it. Being Web powered allowed development of many
changes in the Datascience world. Objects now often expose rich representation; from
Pandas dataframes with as html tables, to more recent &lt;a href="https://github.com/scikit-learn/scikit-learn/pull/14180"&gt;Scikit-learn model&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Today I want to look into a topic that has not evolved much since, and I believe
could use an upgrade. Accessing interactive Documentation when in a Jupyter
session, and what it could become. At the end I'll link to my current prototype
if you are adventurous.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2021/05/rethinking-jupyter-documentation/"&gt;Read more…&lt;/a&gt; (7 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>documentation</category><category>Open-Source</category><category>Python</category><guid>https://labs.quansight.org/blog/2021/05/rethinking-jupyter-documentation/</guid><pubDate>Fri, 07 May 2021 00:01:00 GMT</pubDate></item><item><title>Python packaging in 2021 - pain points and bright spots</title><link>https://labs.quansight.org/blog/2021/01/python-packaging-brainstorm/</link><dc:creator>Ralf Gommers</dc:creator><description>&lt;div&gt;&lt;p&gt;At Quansight we have a weekly "Q-share" session on Fridays where everyone can
share/demo things they have worked on, recently learned, or that simply seem
interesting to share with their colleagues. This can be about anything, from
new utilities to low-level performance, from building inclusive communities
to how to write better documentation, from UX design to what legal &amp;amp;
accounting does to support the business. This week I decided to try something
different: hold a brainstorm on the state of Python packaging today.&lt;/p&gt;
&lt;p&gt;The ~30 participants were mostly from the PyData world, but not exclusively -
it included people with backgrounds and preferences ranging from C, C++ and
Fortran to JavaScript, R and DevOps - and with experience as end-users,
packagers, library authors, and educators. This blog post contains the raw
output of the 30-minute brainstorm (only cleaned up for textual issues) and
my annotations on it (in italics) which capture some of the discussion during
the session and links and context that may be helpful. I think it sketches a
decent picture of the main pain points of Python packaging for users and
developers interacting with the Python data and numerical computing ecosystem.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2021/01/python-packaging-brainstorm/"&gt;Read more…&lt;/a&gt; (11 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>Conda</category><category>conda-forge</category><category>CUDA</category><category>manylinux</category><category>packaging</category><category>pip</category><category>PyData</category><category>PyPI</category><category>Python</category><category>setuptools</category><guid>https://labs.quansight.org/blog/2021/01/python-packaging-brainstorm/</guid><pubDate>Sun, 24 Jan 2021 04:00:00 GMT</pubDate></item><item><title>Making SciPy's Image Interpolation Consistent and Well Documented</title><link>https://labs.quansight.org/blog/2021/01/scipy-ndimage-interpolation/</link><dc:creator>Gregory Lee</dc:creator><description>&lt;div&gt;&lt;h2&gt;SciPy n-dimensional Image Processing&lt;/h2&gt;
&lt;p&gt;SciPy's ndimage module provides a powerful set of general, n-dimensional image processing operations, categorized into areas such as filtering, interpolation and morphology. Traditional image processing deals with 2D arrays of pixels, possibly with an additional array dimension of size 3 or 4 to represent color channel and transparency information. However, there are many scientific applications where we may want to work with more general arrays such as the 3D volumetric images produced by medical imaging methods like computed tomography (CT) or magnetic resonance imaging (MRI) or biological imaging approaches such as light sheet microscopy. Aside from spatial axes, such data may have additional axes representing other quantities such as time, color, spectral frequency or different contrasts. Functions in ndimage have been implemented in a general n-dimensional manner so that they can be applied across 2D, 3D or more dimensions. A more detailed overview of the module is available in the
&lt;a href="https://docs.scipy.org/doc/scipy/reference/tutorial/ndimage.html"&gt;SciPy ndimage tutorial&lt;/a&gt;. SciPy's image functions are also used by downstream libraries such as &lt;a href="https://scikit-image.org"&gt;scikit-image&lt;/a&gt; to implement higher-level algorithms for things like image restoration, segmentation and registration.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2021/01/scipy-ndimage-interpolation/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>Labs</category><category>Open-Source</category><category>Python</category><category>SciPy</category><guid>https://labs.quansight.org/blog/2021/01/scipy-ndimage-interpolation/</guid><pubDate>Fri, 22 Jan 2021 14:00:00 GMT</pubDate></item><item><title>PyTorch-Ignite: training and evaluating neural networks flexibly and transparently</title><link>https://labs.quansight.org/blog/2020/09/pytorch-ignite/</link><dc:creator>Victor Fomin</dc:creator><description>&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;!--# PyTorch-Ignite: training and evaluating neural networks flexibly and transparently--&gt;

&lt;!--div align="center"&gt;
&lt;img width=512 src="https://i.ibb.co/WtbmXJQ/ignite-blog.jpg"/&gt;
&lt;/div--&gt;

&lt;div align="center"&gt;
&lt;img width="512" src="https://i.ibb.co/x8Bhqhj/habr-pytorch-ignite-image.png"&gt;
&lt;/div&gt;&lt;div align="center"&gt;
Authors: Victor Fomin (Quansight), Sylvain Desroziers (IFPEN, France)
&lt;/div&gt;&lt;div&gt;
This post is a general introduction of PyTorch-Ignite. It intends to give a brief but illustrative overview of what PyTorch-Ignite can offer for Deep Learning enthusiasts, professionals and researchers. Following the same philosophy as PyTorch, PyTorch-Ignite aims to keep it simple, flexible and extensible but performant and scalable.
&lt;/div&gt;&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/09/pytorch-ignite/"&gt;Read more…&lt;/a&gt; (28 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><category>Deep Learning</category><category>Labs</category><category>Machine Learning</category><category>Neural Networks</category><category>Python</category><category>PyTorch</category><category>Tutorial</category><guid>https://labs.quansight.org/blog/2020/09/pytorch-ignite/</guid><pubDate>Thu, 10 Sep 2020 05:00:00 GMT</pubDate></item><item><title>Traitlets - an introduction &amp; use in Jupyter configuration management</title><link>https://labs.quansight.org/blog/2020/08/what-are-traitlets/</link><dc:creator>Matthias Bussonnier, Tony Fast</dc:creator><description>&lt;div&gt;&lt;p&gt;You have probably seen Traitlets in applications, you likely even use it. The package has nearly 5 million downloads
on &lt;a href="https://anaconda.org/conda-forge/traitlets"&gt;conda-forge&lt;/a&gt; alone.&lt;/p&gt;
&lt;h2&gt;But, what is Traitlets ?&lt;/h2&gt;
&lt;p&gt;In this post we'll answer this question along with where Traitlets came from, its applications, and a bit of history.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/08/what-are-traitlets/"&gt;Read more…&lt;/a&gt; (8 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>community</category><category>historical</category><category>IPython</category><category>Jupyter</category><category>Labs</category><category>Python</category><category>traitlets</category><guid>https://labs.quansight.org/blog/2020/08/what-are-traitlets/</guid><pubDate>Sun, 30 Aug 2020 09:00:00 GMT</pubDate></item><item><title>Creating a Portable Python Environment from Imports</title><link>https://labs.quansight.org/blog/2020/06/portable-python-env/</link><dc:creator>Kim Pevey</dc:creator><description>&lt;div&gt;&lt;p&gt;Python environments provide sandboxes in which packages can be added.
Conda helps us deal with the requirements and dependencies of those packages.
Occasionally we find ourselves working in a constrained remote machine which
can make development challenging. Suppose we wanted to take our exact dev
environment on the remote machine and recreate it on our local machine.
While conda relieves the package dependency challenge, it can be hard to
reproduce the exact same environment.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/06/portable-python-env/"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>Conda</category><category>Conda-Pack</category><category>Depfinder</category><category>Python</category><guid>https://labs.quansight.org/blog/2020/06/portable-python-env/</guid><pubDate>Tue, 30 Jun 2020 19:39:56 GMT</pubDate></item></channel></rss>